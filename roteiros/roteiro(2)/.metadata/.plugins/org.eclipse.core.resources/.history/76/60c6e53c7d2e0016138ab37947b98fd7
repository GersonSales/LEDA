package sorting.divideAndConquer;

import sorting.AbstractSorting;

/**
 * Quicksort is based on the divide-and-conquer paradigm.
 * The algorithm chooses a pivot element and rearranges the elements of the
 * interval in such a way that all elements lesser than the pivot go to the
 * left part of the array and all elements greater than the pivot, go to the
 * right part of the array. Then it recursively sorts the left and the right parts.
 * Notice that if the list has length == 1, it is already sorted.
 */
public class QuickSort<T extends Comparable<T>> extends AbstractSorting<T> {

	@Override
	public void sort(T[] array,int leftIndex, int rightIndex) {
	    if (leftIndex < rightIndex) {
	        int particao = particao(array, leftIndex, rightIndex);
	    }
	    
	    
//	    algorithm quicksort(A, lo, hi) is
//	    if lo < hi then
//	        p := partition(A, lo, hi)
//	        quicksort(A, lo, p – 1)
//	        quicksort(A, p + 1, hi)

	    
		// TODO Auto-generated method stub
		throw new RuntimeException("Not implemented yet!");
	}

    private int particao(T[] array, int leftIndex, int rightIndex) {
        T pivo = array[rightIndex];
        int i = leftIndex;
        for (int j = leftIndex; j < rightIndex - 1; j ++) {
            if (array[j].compareTo(pivo) <= 0) {
                sorting.Util.swap(array, i, j);
                i ++;
            }
        }
    //  algorithm partition(A, lo, hi) is
//      pivot := A[hi]
//      i := lo        // place for swapping
//      for j := lo to hi – 1 do
//          if A[j] ≤ pivot then
//              swap A[i] with A[j]
//              i := i + 1
//      swap A[i] with A[hi]
//      return i
        // TODO Auto-generated method stub
        return 0;
    }
}
